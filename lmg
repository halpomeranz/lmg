#!/bin/bash
#
# lmg -- Linux Memory Grabber
#
# Automation script for dumping Linux memory via LiME and building
# a Volatility(TM) profile.  "lmg -y" will take care of the entire
# process without prompting and save everything to the "capture"
# sub-directory wherever the lmg program is installed (e.g. a thumb drive).
# If you prefer raw dumps add "-F raw" (the default is "lime" format).
#
# See INSTALL doc for instructions for how to configure a thumb drive
# for use with this tool.
#
# Hal Pomeranz (hal@deer-run.com), 2016-05-04
#
# No warranty expressed or implied.
# Distributed under the Creative Commons "Attribution" (CC BY) License
# See https://creativecommons.org/licenses/

if [[ $EUID != 0 ]]; then
    echo This script must run as root!
    exit 255;
fi

FORMAT=lime
YESTOALL=n
while getopts ":B:c:d:F:y" opt; do
  case $opt in
      B)
	  BUILDDIR=$OPTARG
	  ;;
      c)
	  CASEID=$OPTARG
	  ;;
      d)
	  TARGETDIR=$OPTARG
	  ;;
      F)
	  FORMAT=$OPTARG
	  ;;
      y)
	  YESTOALL=y
	  ;;
      \?)
	  echo "Usage: $0 [-y] [-F lime|raw] [-d outputdir] [-B builddir] [-c caseID]"
	  exit 255
	  ;;
  esac
done

# Linux USB 2.0 speedup -- see http://marc-abramowitz.com/archives/2007/02/17/
for f in $(find /sys -name max_sectors); do
    echo 1024 >>$f
done

# Figure out where the tool is being run from and create an absolute pathname.
#
TOOLDIR=$(dirname $0)
[[ $(echo $TOOLDIR | cut -c1) != "/" ]] && TOOLDIR=$(pwd)/$TOOLDIR
TOOLDIR=$(echo $TOOLDIR | sed 's/\/\.*$//')

# The default is that all other paths are relative to $TOOLDIR, but users may
# select alternate directories with -d and -B
#
TARGETDIR=${TARGETDIR:=$TOOLDIR}
BUILDDIR=${BUILDDIR:=$TARGETDIR}

# Create absolute pathnames for TARGETDIR and BUILDDIR as necessary
[[ $(echo $TARGETDIR | cut -c1) != "/" ]] && TARGETDIR=$(pwd)/$TARGETDIR
TARGETDIR=$(echo $TARGETDIR | sed 's/\/\.*$//')
[[ $(echo $BUILDDIR | cut -c1) != "/" ]] && BUILDDIR=$(pwd)/$BUILDDIR
BUILDDIR=$(echo $BUILDDIR | sed 's/\/\.*$//')

# We need $DIRLIST for searching
declare -A DIRS
DIRS[$TOOLDIR]=1
DIRS[$TARGETDIR]=1
DIRS[$BUILDDIR]=1
DIRLIST="${!DIRS[@]}"

# Try to keep temp files under build directory-- avoid impact to
# system where tool is running...
#
mkdir -p $BUILDDIR/tmp
export TMPDIR=$BUILDDIR/tmp


KVER=$(uname -r)                    # e.g., "3.2.0-41-generic"
CPU=$(uname -m)                     # typically "x86_64" or "i686"
HOST=$(hostname)
TIMESTAMP=$(date '+%F_%H.%M.%S')    # YYYY-MM-DD_hh.mm.ss


# CAPTUREDIR is where captured memory image, profile, and bash exe end up.
# 
if [[ -z $CASEID ]]; then
    CAPTUREDIR=$TARGETDIR/capture/$HOST-$TIMESTAMP
else
    CAPTUREDIR=$TARGETDIR/capture/$CASEID
fi
mkdir -p $CAPTUREDIR


# Try to find a pre-built LiME module
LIMEMOD=$(find $DIRLIST -name lime-$KVER-$CPU.ko | head -1)

# If not found, see if we should try to build one
if [[ -z $LIMEMOD ]]; then
    if [[ $YESTOALL == 'n' ]]; then
	echo -n 'Try to build LiME kernel module? [N|y] '
	read mod
    fi
    if [[ $YESTOALL == 'y' || $mod == 'y' || $mod == 'Y' ]]; then
	LIMEDIR=$(dirname $(find $BUILDDIR -name lime.h) 2>/dev/null)
	if [[ -z $LIMEDIR ]]; then
	    echo "Didn't find lime.h under $BUILDDIR"
	    LIMEDIR=$(dirname $(find $TOOLDIR -name lime.h) 2>/dev/null)
	    if [[ -z $LIMEDIR ]]; then
		echo "Can't find lime.h under $TOOLDIR... exiting!"
		exit
	    else
		echo "Copying LiME source from $LIMEDIR to $BUILDDIR/lime"
		cp -r $LIMEDIR $BUILDDIR/lime
		LIMEDIR=$BUILDDIR/lime
	    fi
	fi
	cd $LIMEDIR
	make
	LIMEMOD=$LIMEDIR/lime-$KVER-$CPU.ko
	if [[ ! (-f $LIMEMOD) ]]; then
	    echo Still no matching kernel module found... exiting!
	    exit 255
	fi
    else
	echo No LiME module found... exiting
	exit 255
    fi
fi

# If we get here, we should have a LiME module named $LIMEMOD.
# Use module to capture memory to $CAPTUREDIR
#
echo LiME module is $LIMEMOD
echo Dumping memory in \"$FORMAT\" format to $CAPTUREDIR
echo -n This could take a while...
insmod $LIMEMOD "format=$FORMAT path=$CAPTUREDIR/$HOST-$TIMESTAMP-memory.$FORMAT"
echo Done!  
echo -n Cleaning up...
rmmod lime
echo Done!

# We want a copy of the local bash executable so we can find the offset
# of the history data structure.
#
echo -n Grabbing a copy of /bin/bash...
cp /bin/bash $CAPTUREDIR/$HOST-$TIMESTAMP-bash
echo Done!

# Generate a volatilityrc prototype. Use with:
#    vol.py --conf-file=/path/to/capture/dir/volatilityrc
#
echo -n Writing volatilityrc to $CAPTUREDIR...
ARCH=x$(echo $CPU | sed 's/.*\(..\)/\1/')
PROFILE=$(echo Linux$HOST-$TIMESTAMP-profile$ARCH | sed 's/\./_/g')
cat >$CAPTUREDIR/volatilityrc <<EOF
[DEFAULT]
PLUGINS=$CAPTUREDIR
PROFILE=$PROFILE
LOCATION=file:///$CAPTUREDIR/$HOST-$TIMESTAMP-memory.$FORMAT
EOF
echo Done!

# Last step is to build a profile for the system.  If you don't want
# this, then you don't have to install dwarfdump or volatility on your
# thumb drive.  lmg will give up if these directories aren't found.
#
if [[ $YESTOALL == 'n' ]]; then
    echo -n 'Compile profile for this system? [N|y] '
    read prof
fi
if [[ $YESTOALL == 'y' || $prof == 'y' || $prof = 'Y' ]]; then
    VOLDIR=$(dirname $(find $BUILDDIR -name module.c) 2>/dev/null)
    if [[ -z $VOLDIR ]]; then
	echo "Didn't find volatility directory under $BUILDDIR"
	VOLDIR=$(dirname $(find $TOOLDIR -name module.c) 2>/dev/null)
	if [[ -z $VOLDIR ]]; then
	    echo "Didn't find volatility directory under $TOOLDIR... exiting!"
	    exit 255
	else
	    echo Copying volatility directory to $BUILDDIR/vol
	    cp -r $VOLDIR $BUILDDIR/vol
	    VOLDIR=$BUILDDIR/vol
	fi
    fi
    
    DWARFPROG=$(find $DIRLIST -name dwarfdump-$CPU | head -1)
    if [[ ! ( -x $DWARFPROG ) ]]; then
	echo Failed to find program dwarfdump-$CPU.  Giving up!
	exit 255
    fi

    # Put the right dwarfdump for this CPU architecture into the PATH
    rm -f $TMPDIR/dwarfdump
    ln -s $DWARFPROG $TMPDIR/dwarfdump
    export PATH=$TMPDIR:$PATH

    # Build module.c against kernel headers found on local system and
    # with System.map from local /boot directory.
    cd $VOLDIR
    make clean dwarf
    if [[ ! (-f module.dwarf) ]]; then
	echo Failed to make module.dwarf.  Giving up!
	exit 255
    fi
    if [[ ! (-f /boot/System.map-$KVER) ]]; then
	echo /boot/System.map-$KVER not found.  Giving up!
	exit 255
    fi

    # Profile ends up in $CAPTUREDIR with memory image
    zip $CAPTUREDIR/$HOST-$TIMESTAMP-profile.zip module.dwarf /boot/System.map-$KVER
fi


# Create a volatilityrc file for this session?
# Makes it easy to run vol.py --conf-file=/path/to/volatilityrc and have
# profile, target file, etc set for you
if [[ $YESTOALL == 'n' ]]; then
    echo -n 'Create volatilityrc for this session? [N|y] '
    read createrc
fi
if [[ $YESTOALL == 'y' || $createrc == 'y' || $createrc = 'Y' ]]; then

    # set up variables matching what the profile will end up being
    if [[ $CPU == 'x86_64' ]]; then
        ARCH=x64
    fi
    if [[ $CPU == 'i686' ]]; then
        ARCH=x86
    fi
    PROFILENAME=Linux$HOST-$TIMESTAMP-profile$ARCH

    # change . to _
    PROFILENAME=${PROFILENAME//\./_}


    cat >$TOPDIR/capture/$HOST-$TIMESTAMP/volatilityrc <<EOL
[DEFAULT]
PLUGINS=$TOPDIR/capture/$HOST-$TIMESTAMP/
PROFILE=$PROFILENAME
LOCATION=file:///$TOPDIR/capture/$HOST-$TIMESTAMP/$HOST-$TIMESTAMP-memory.$FORMAT
EOL

fi